#include "boards.h"
#include "spi_driver.h"
#include "spi_config.h"
#include "nrf_delay.h"
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"
#include "nrf_gpio.h"
#include <stddef.h>
#include "lpback_test.h"
#include "w5500_config.h"
#include "w5500.h"

/*******************************************************************************
* 函数名  : W5500_Initialization
* 描述    : W5500初始货配置
* 输入    : 无
* 输出    : 无
* 返回值  : 无
* 说明    : 初始化W5500寄存器函数,检查网关服务器,指定Socket(0~7)初始化,初始化端口0
*******************************************************************************/
void W5500_Initialization(void)
{
	W5500_Init();		//初始化W5500寄存器函数
	Detect_Gateway();	//检查网关服务器 
	Socket_Init(0);		//指定Socket(0~7)初始化,初始化端口0
}

/*******************************************************************************
* 函数名  : Load_Net_Parameters
* 描述    : 装载网络参数
* 输入    : 无
* 输出    : 无
* 返回值  : 无
* 说明    : 网关、掩码、物理地址、本机IP地址、端口号、目的IP地址、目的端口号、端口工作模式
*******************************************************************************/
void Load_Net_Parameters(void)
{
	Gateway_IP[0] = 192;//加载网关参数
	Gateway_IP[1] = 168;
	Gateway_IP[2] = 1;
	Gateway_IP[3] = 100;

	Sub_Mask[0]=255;//加载子网掩码
	Sub_Mask[1]=255;
	Sub_Mask[2]=255;
	Sub_Mask[3]=0;

	Phy_Addr[0]=0x0c;//加载物理地址
	Phy_Addr[1]=0x29;
	Phy_Addr[2]=0xab;
	Phy_Addr[3]=0x7c;
	Phy_Addr[4]=0x00;
	Phy_Addr[5]=0x01;

	IP_Addr[0]=192;//加载本机IP地址
	IP_Addr[1]=168;
	IP_Addr[2]=1;
	IP_Addr[3]=199;

	Phy_Addr[4]=IP_Addr[2];
	Phy_Addr[5]=IP_Addr[3];
	
	S0_Port[0] = 0x13;//加载端口0的端口号5000 
	S0_Port[1] = 0x88;

	S0_Mode=UDP_MODE;//加载端口0 （socket 0）的工作模式,UDP模式
}

/*******************************************************************************
* 函数名  : W5500_Socket_Set
* 描述    : W5500端口初始化配置
* 输入    : 无
* 输出    : 无
* 返回值  : 无
* 说明    : 分别设置4个端口,根据端口工作模式,将端口置于TCP服务器、TCP客户端或UDP模式.
*			从端口状态字节Socket_State可以判断端口的工作情况
*******************************************************************************/
void W5500_Socket_Set(void)
{
	if(S0_State==0)//端口0初始化配置
	{
		if(S0_Mode==TCP_SERVER)//TCP服务器模式 
		{
			if(Socket_Listen(0)==TRUE)
				S0_State=S_INIT;
			else
				S0_State=0;
		}
		else if(S0_Mode==TCP_CLIENT)//TCP客户端模式 
		{
			if(Socket_Connect(0)==TRUE)
				S0_State=S_INIT;
			else
				S0_State=0;
		}
		else//UDP模式 
		{
			if(Socket_UDP(0)==TRUE)
				S0_State=S_INIT|S_CONN;
			else
				S0_State=0;
		}
	}
}
/*******************************************************************************
* 函数名  : Process_Socket_Data
* 描述    : W5500接收并发送接收到的数据
* 输入    : s:端口号
* 输出    : 无
* 返回值  : 无
* 说明    : 本过程先调用S_rx_process()从W5500的端口接收数据缓冲区读取数据,
*			然后将读取的数据从Rx_Buffer拷贝到Temp_Buffer缓冲区进行处理。
*			处理完毕，将数据从Temp_Buffer拷贝到Tx_Buffer缓冲区。调用S_tx_process()
*			发送数据。
*******************************************************************************/
void Process_Socket_Data(SOCKET s)
{
	unsigned short size;
	// 从socket接收缓冲区读取数据
	size=Read_SOCK_Data_Buffer(s, Rx_Buffer);

	// 提取目的IP地址和端口号
	UDP_DIPR[0] = Rx_Buffer[0];
	UDP_DIPR[1] = Rx_Buffer[1];
	UDP_DIPR[2] = Rx_Buffer[2];
	UDP_DIPR[3] = Rx_Buffer[3];

	UDP_DPORT[0] = Rx_Buffer[4];
	UDP_DPORT[1] = Rx_Buffer[5];

	// 将接收到的数据复制到发送缓冲区
	memcpy(Tx_Buffer, Rx_Buffer+8, size-8);
	// 将处理后的数据写入W5500的socket发送缓冲区			
	Write_SOCK_Data_Buffer(s, Tx_Buffer, size-8);
}


/**
 * @brief Work-around for transmitting 1 byte with SPIM.
 *
 * @param spim: The SPIM instance that is in use.
 * @param ppi_channel: An unused PPI channel that will be used by the workaround.
 * @param gpiote_channel: An unused GPIOTE channel that will be used by the workaround.
 * 
 * @warning Must not be used when transmitting multiple bytes.
 * @warning After this workaround is used, the user must reset the PPI channel and the
 GPIOTE channel before attempting to transmit multiple bytes.
 */
void setup_workaround_for_ftpan_58(NRF_SPIM_Type * spim, uint32_t ppi_channel, uint32_t gpiote_channel)
{
	 // Create an event when SCK toggles.
	 NRF_GPIOTE->CONFIG[gpiote_channel] = (
	 GPIOTE_CONFIG_MODE_Event <<
	 GPIOTE_CONFIG_MODE_Pos
	 ) | (
	 spim->PSEL.SCK <<
	 GPIOTE_CONFIG_PSEL_Pos
	 ) | (
	 GPIOTE_CONFIG_POLARITY_Toggle <<
	 GPIOTE_CONFIG_POLARITY_Pos
	 );
	 // Stop the spim instance when SCK toggles.
	 NRF_PPI->CH[ppi_channel].EEP = (uint32_t)&NRF_GPIOTE->EVENTS_IN[gpiote_channel];
	 NRF_PPI->CH[ppi_channel].TEP = (uint32_t)&spim->TASKS_STOP;
	 NRF_PPI->CHENSET = 1U << ppi_channel;
	 // The spim instance cannot be stopped mid-byte, so it will finish
	 // transmitting the first byte and then stop. Effectively ensuring
	 // that only 1 byte is transmitted.
}
void spi_ppi_set(void)
{
	setup_workaround_for_ftpan_58(NRF_SPIM0, 6, 0);
}



int main(void)
{
	
		bsp_board_init(BSP_INIT_LEDS);

		APP_ERROR_CHECK(NRF_LOG_INIT(NULL));
		NRF_LOG_DEFAULT_BACKENDS_INIT();	
		
		spi_init();
		Load_Net_Parameters();		//装载网络参数	
		W5500_Hardware_Reset();		//硬件复位W5500
		W5500_Initialization();		//W5500初始货配置
	
		while (1)
    	{	
				W5500_Socket_Set();//W5500端口初始化配置
				

				W5500_Interrupt_Process();//W5500中断处理程序框架

				if((S0_Data & S_RECEIVE) == S_RECEIVE)//如果Socket0接收到数据
				{
					S0_Data&=~S_RECEIVE;
					Process_Socket_Data(0);//W5500接收并发送接收到的数据
				}
	
		
    	}

}
